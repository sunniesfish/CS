# 가상 메모리

> **가상 메모리**란 실제 물리 메모리(RAM)의 추상화 된 메모리 주소 공간이다.

## 추상화

가상 메모리는 RAM과 디스크를 모두 사용한다. 이 때 사용되는 디스크 공간을 **스왑 공간**이라고 한다. 스왑은 RAM의 공간이 부족한 경우 사용하게 된다. **페이징**을 통해 자주 사용하는 페이지를 RAM에 유지하고 자주 사용하지 않는 페이지를 디스크로 옮겨 사용하게 된다.

## 가상 메모리 내부 영역 구성

낮은주소 -> 높은주소 순

- **Text Segment(Code)** : 프로그램의 실행 코드가 저장. 읽기전용이며 여러 프로세스가 같은 바이너리를 사용하는 경우 공유될 수 있다.
- **Data Segment** : 초기화된 전역 변수 / Static 변수 저장
- **BSS Segment** : 초기화 되지 않은 전역 변수 / Static 변수 저장
- **Heap** : 런타임에서 동적 메모리 할당(malloc/new)이 이뤄지는 영역. 높은 주소 방향으로 성장함
- **Stack** : 기본 타입 변수와 참조 주소값, 레지스터 저장. 낮은 주소 방향으로 성장.
- **Kernal**

## Heap과 Stack

Heap과 Stack 모두 런타임에 사용된다. 다만 Stack의 경우 빌드 타임에 각 함수의 **Stack frame**의 크기가 계산된다. 이 때 계산되는 Stack frame의 레이아웃에는 호출에 필요한 지역변수 크기, 인자 전달 방법, 저장해야 할 레지스터, 반환 주소 등이 포함된다.

런타임에 함수가 호출되었을 때 새로운 **Stack frame**이 생성된다. 이 때 매개변수, 반환 주소, 지역 변수 등이 저장되는데 이 때 동적 변수의 경우 주소(포인터)가 저장되고 실제 메모리는 **Heap**에 할당된다. 함수 종료 시에는 **Stack frame**은 자동으로 pop되며 메모리가 해제 되나 **Heap**의 경우 여전히 존재한다.

**Heap**의 경우 여러 함수에서 참조될 수 있기 때문에 자동으로 해제되지 않는다. 따라서 해당 값이 필요하지 않은 경우 수동으로 해제해야 한다.

### 속도 측면 비교

| 특성        | Stack                        | Heap           |
| ----------- | ---------------------------- | -------------- |
| 속도        | 빠름                         | 느림           |
| 메모리 할당 | 연속적                       | 분산적         |
| 크기        | 제한적 (Stack Overflow 위험) | 동적 확장 가능 |
| 캐시 적합성 | 높음                         | 낮음           |

**Stack**이 **Heap**보다 빠르다. **Stack**의 경우 크기가 제한되어 있고(때문에 **Stack Overflow**의 위험이 있음) 메모리가 연속적으로 할당되므로 단순히 stack pointer만 이동해서 공간을 확보하고 할당/해제하여 빠르고 캐시 친화적인 반면 **Heap**의 경우 런타임에 동적으로 크기가 결정되어 메모리가 흩어져 있어 할당시에 풀 안에서 빈 공간을 찾아야 하고 캐시 미스가 더 자주 발생하여 비교적 느리다.

스레드 독립성 면에서 **Stack**은 각 스레드마다 독립적으로 존재하여 동기화의 필요가 없으나 **Heap**의 경우 위에서 언급한 것처럼 여러 함수(즉 여러 스레드)에서 공유하기 때문에 Race Condition의 위험이 있어 할당/해제 시 Lock과 같은 동기화 처리가 필요하여 오버헤드가 발생한다.

## 페이징과 스왑

_이 섹션은 아직 작성되지 않았습니다._

---

## 관련 문서

- [[개요]]

#memory #OS #heap #stack
