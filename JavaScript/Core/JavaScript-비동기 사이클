

# ✅ Node.js 이벤트 루프와 비동기 처리 메커니즘 종합 정리 (한 Phase 내부 과정 포함)

---

## 🔁 1. 이벤트 루프란?

* 이벤트 루프(Event Loop)는 Node.js가 **비동기 작업과 콜백 실행을 효율적으로 관리하기 위해 동작하는 핵심 메커니즘**입니다.
* Node.js는 싱글 스레드지만, 이벤트 루프를 통해 여러 작업을 동시에 처리하는 것처럼 보이는 동시성(Concurrency)을 제공합니다.

---

## 🧭 2. 이벤트 루프의 전체 사이클과 Phase

* 이벤트 루프는 여러 \*\*Phase(단계)\*\*가 순차적으로 실행되는 반복 사이클입니다.
* 각 Phase는 특정 종류의 마크로태스크(Macro Task) 큐를 관리하며, 큐에 등록된 작업을 하나씩 꺼내 실행합니다.

### 이벤트 루프 Phase 순서

```
1. timers
2. pending callbacks
3. idle / prepare (내부용)
4. poll
5. check
6. close callbacks
```

---

## ⛓️ 3. 각 Phase에서 수행되는 역할과 실행되는 작업 종류

| Phase                    | 역할 및 설명                                | 실행 작업 예시                    |
| ------------------------ | -------------------------------------- | --------------------------- |
| **1. Timers**            | 만료된 `setTimeout` / `setInterval` 콜백 실행 | `setTimeout(() => {}, 0)` 등 |
| **2. Pending Callbacks** | 일부 시스템 콜백 실행 (TCP 에러 등)                | 네트워크 오류 콜백                  |
| **3. Idle / Prepare**    | Node.js 내부 전용, 사용자가 직접 관여하지 않음         | 내부 타이머, prepare 작업          |
| **4. Poll**              | I/O 완료된 콜백 실행, I/O 대기 및 큐 확인           | 파일 읽기, 네트워크 I/O 콜백          |
| **5. Check**             | `setImmediate()` 콜백 실행                 | `setImmediate(() => {})`    |
| **6. Close Callbacks**   | 소켓/스트림 종료 콜백 실행                        | `socket.on('close')` 등      |

---

## 🧩 4. 한 Phase 내부에서의 상세 실행 흐름

한 phase 안에서 이벤트 루프가 수행하는 과정은 다음과 같습니다:

### 4-1. 해당 Phase의 **마크로태스크 큐** 확인

* 그 phase에 등록된 마크로태스크 큐에서 **하나씩 순차적으로 작업을 꺼내어 실행**합니다.
* 예를 들어, Timers phase에서는 만료된 `setTimeout` 콜백을 큐에서 꺼내 실행합니다.

### 4-2. **마크로태스크 콜백 실행**

* 꺼낸 콜백(마크로태스크)을 실행하는 동안 동기 작업이 수행됩니다.
* 이 과정에서 비동기 작업 등록이 발생할 수 있습니다.

### 4-3. **비동기 작업 등록 처리**

* 실행 중 다음과 같은 비동기 작업 등록이 가능합니다:

  * `process.nextTick(callback)` → **NextTick 큐**에 등록 (Node.js 특화)
  * `Promise.then()`, `queueMicrotask(callback)` → **마이크로태스크 큐**에 등록
  * `setTimeout()`, `setImmediate()` → 해당 phase의 마크로태스크 큐에 등록

### 4-4. **마크로태스크 콜백 종료 직전: NextTick 큐 처리**

* Node.js는 마크로태스크 콜백이 종료되기 직전에,
* **`process.nextTick` 큐를 완전히 비웁니다.**
* nextTick 큐에 있는 콜백을 순서대로 실행하며, 실행 중 새 nextTick 콜백 등록 시 즉시 처리합니다.

### 4-5. **마크로태스크 콜백 종료 후: 마이크로태스크 큐 처리**

* 그 다음으로 **마이크로태스크 큐(Promise.then, queueMicrotask 등)를 완전히 비웁니다.**
* 마이크로태스크 큐가 비워질 때까지 계속 실행하며, 실행 중 새 마이크로태스크가 추가되면 계속 처리합니다.

### 4-6. **다음 마크로태스크 또는 Phase로 이동**

* 현재 phase의 마크로태스크 큐에서 다음 작업을 꺼내 실행하거나,
* 큐가 비었으면 다음 phase로 넘어갑니다.

---

## ⚙️ 5. 마이크로태스크( Microtask) 큐와 NextTick 큐 차이

| 구분                          | 설명                          | 실행 시점                                |
| --------------------------- | --------------------------- | ------------------------------------ |
| `process.nextTick()`        | Node.js 전용, 마이크로태스크보다 우선 실행 | **마크로태스크 콜백 종료 직전 즉시 실행**            |
| 일반 마이크로태스크 (Promise.then 등) | 표준 마이크로태스크 큐에 등록            | **NextTick 큐 처리 후, 마크로태스크 종료 직후 실행** |

---

## 🔄 6. 전체적인 비동기 처리 흐름 요약

1. 이벤트 루프가 한 phase를 선택하고 해당 phase의 마크로태스크 큐에서 작업을 하나 꺼내 실행한다.
2. 마크로태스크 실행 중 비동기 콜백(`process.nextTick`, `Promise.then`, `queueMicrotask`) 등록 가능.
3. 마크로태스크 콜백 종료 직전에 `process.nextTick` 큐를 완전히 비운다.
4. 마이크로태스크 큐를 완전히 비운다.
5. 마크로태스크 큐에서 다음 작업을 실행하거나, 큐가 비면 다음 phase로 넘어간다.
6. 이 사이클을 반복한다.

---

## 🧩 7. 주요 비동기 메서드 및 그 동작 위치

| 메서드                          | 태스크 종류            | 실행 Phase             | 설명                 |
| ---------------------------- | ----------------- | -------------------- | ------------------ |
| `setTimeout(cb, ms)`         | 마크로태스크            | Timers phase         | 지정한 시간 후 실행        |
| `setInterval(cb, ms)`        | 마크로태스크            | Timers phase         | 지정한 시간마다 반복 실행     |
| `setImmediate(cb)`           | 마크로태스크            | Check phase          | Poll phase 후 실행    |
| `Promise.resolve().then(cb)` | 마이크로태스크           | 마크로태스크 큐             | 마크로태스크 큐에서 즉시 실행   |
| `queueMicrotask(cb)`         | 마이크로태스크           | 마크로태스크 큐             | 마이크로태스크 큐에 등록      |
| `process.nextTick(cb)`       | 마이크로태스크 (최우선)     | NextTick 큐           | 마크로태스크 종료 직전 즉시 실행 |
| `fs.readFile(...)`           | 비동기 I/O + 콜백      | Poll phase + 마이크로태스크 | I/O 완료 시 콜백 실행     |
| `fetch()` (Node.js 18+)      | 비동기 I/O + Promise | Poll + 마이크로태스크       | 네트워크 요청            |

---

## 🧪 8. 종합 예제 및 실행 순서

```js
console.log("start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

setImmediate(() => {
  console.log("setImmediate");
});

Promise.resolve().then(() => {
  console.log("promise1");
  queueMicrotask(() => {
    console.log("queueMicrotask in promise1");
  });
});

process.nextTick(() => {
  console.log("nextTick");
});

console.log("end");
```

### 실행 순서 및 이유

| 순서 | 출력 내용                      | 이유 설명                          |
| -- | -------------------------- | ------------------------------ |
| 1  | start                      | 동기 코드                          |
| 2  | end                        | 동기 코드                          |
| 3  | nextTick                   | 마크로태스크 콜백 종료 직전, NextTick 큐 처리 |
| 4  | promise1                   | 일반 마이크로태스크 큐에서 첫번째 작업 실행       |
| 5  | queueMicrotask in promise1 | promise1 내에서 등록된 마이크로태스크 실행    |
| 6  | setTimeout                 | Timers phase 마크로태스크 실행         |
| 7  | setImmediate               | Check phase 마크로태스크 실행          |

---

## 🔚 9. 결론

* 이벤트 루프는 **각 phase별로 마크로태스크 큐를 순차적으로 처리**하고,
* 각 마크로태스크가 끝나면 **NextTick 큐와 마이크로태스크 큐를 완전히 비웁니다.**
* `process.nextTick()` 콜백은 마이크로태스크보다 우선 처리되어, 실행 시점을 더 앞당겨 줍니다.
* 비동기 함수의 실행 타이밍과 우선순위를 이해하기 위해선 **phase, 마크로태스크 큐, 마이크로태스크 큐, nextTick 큐**의 구조와 흐름을 반드시 알아야 합니다.
* 이를 명확히 알면 Node.js 비동기 프로그래밍에서 예상치 못한 실행 순서 문제를 예방할 수 있습니다.


---

# Node.js 이벤트 루프 내부: 콜스택, 마크로태스크 큐, 마이크로태스크 큐 간 상호작용 - 네트워크 요청 예시

---

## 1. 네트워크 요청 함수 호출 — 콜스택에 쌓임

* 사용자가 `fetch(url)` 같은 네트워크 비동기 요청 함수를 호출한다.
* 이 함수가 호출되면서 **콜스택에 실행 컨텍스트가 쌓이고 동기 코드가 실행**된다.
* `fetch()` 내부에서는 **`Promise` 객체를 즉시 생성하여 반환**한다 (아직 `pending` 상태).
* 동시에, 네트워크 I/O 요청이 OS에 비동기적으로 전달되고, 이 요청에 대응하는 콜백과 식별자가 **Node.js libuv 내부 자료구조에 등록**된다.
* `fetch()` 호출 함수는 콜스택에서 완료되어 제거된다.

---

## 2. 콜스택이 비워지고 이벤트 루프가 시작

* 동기 코드가 모두 실행되어 콜스택이 완전히 비워진다.
* 이때 이벤트 루프가 활성화되어 대기 중인 작업을 처리할 준비를 한다.

---

## 3. (시간 경과) 운영체제가 네트워크 응답을 감지

* 네트워크 요청에 대한 응답이 도착하면 OS가 이를 인지하고 Node.js의 libuv에 완료 신호를 보낸다.
* libuv는 응답에 매핑된 콜백을 찾아 **이벤트 루프의 적절한 phase의 마크로태스크 큐**(주로 `poll` phase)에 해당 콜백을 넣는다.

---

## 4. 이벤트 루프가 마크로태스크 큐에서 콜백 실행

* 이벤트 루프는 현재 phase(예: `poll`)의 마크로태스크 큐에서 하나씩 콜백을 꺼내 실행한다.
* 콜스택에 콜백 함수 실행 컨텍스트가 쌓이고 실행된다.
* 이 콜백 내부에서 `Promise`의 `resolve()`가 호출되어 **Promise 상태가 `pending` → `fulfilled`로 변한다.**

---

## 5. `Promise.resolve()` 호출과 마이크로태스크 큐 등록

* `Promise`가 `resolve()`되면, 연결된 `.then()` 콜백은 **마이크로태스크 큐에 등록**된다.
* 이 마이크로태스크 큐는 **현재 실행 중인 마크로태스크가 끝난 직후 반드시 비워져야 하는 우선순위 높은 큐**이다.

---

## 6. 마크로태스크(네트워크 콜백) 종료 후, 마이크로태스크 큐 실행

* 마크로태스크 콜백 함수 실행이 완전히 종료되어 콜스택이 비워지면,
* 이벤트 루프는 즉시 **마이크로태스크 큐를 비워서 모든 등록된 `.then()` 콜백들을 실행한다.**
* 만약 실행 도중 추가적인 마이크로태스크가 등록되면, 마이크로태스크 큐는 완전히 빌 때까지 계속 실행한다.

---

## 7. 마이크로태스크 큐가 모두 비워지면 다음 마크로태스크 실행

* 마이크로태스크 큐가 완전히 처리된 이후에야 이벤트 루프는
* 다음 phase로 넘어가거나 마크로태스크 큐에서 다음 콜백을 꺼내 실행하는 것을 계속한다.

---

# 요약 표로 보기

| 단계 번호 | 처리 주체        | 처리 내용                                            | 상태 변화 및 큐 등록                                   |
| ----- | ------------ | ------------------------------------------------ | ---------------------------------------------- |
| 1     | 콜스택          | `fetch()` 호출, `Promise` 반환, 네트워크 I/O 요청 libuv 등록 | Promise 상태: `pending`                          |
| 2     | 콜스택          | 동기 코드 종료, 콜스택 비워짐                                | 이벤트 루프 대기 상태                                   |
| 3     | 운영체제 + libuv | 네트워크 응답 감지, 콜백을 이벤트 루프 마크로태스크 큐에 등록              | 콜백 대기 (poll phase 마크로태스크 큐)                    |
| 4     | 이벤트 루프       | 마크로태스크 콜백 실행 (콜스택에 쌓임)                           | `Promise.resolve()` 호출, Promise 상태 `fulfilled` |
| 5     | 이벤트 루프       | 마이크로태스크 큐에 `.then()` 콜백 등록                       | 마이크로태스크 큐에 콜백 추가                               |
| 6     | 이벤트 루프       | 마이크로태스크 큐 완전 실행 (콜스택에서 하나씩 실행)                   | Promise 체이닝 콜백 실행                              |
| 7     | 이벤트 루프       | 다음 마크로태스크 실행 또는 phase 전환                         | 반복                                             |

---

# 추가 참고

* `process.nextTick()` 큐는 일반 마이크로태스크보다 우선 실행됩니다.
* 마이크로태스크 큐 실행 중 새로운 마이크로태스크가 등록되면 계속 실행됩니다.
* 각 phase에서 **마크로태스크는 한 번에 하나씩 실행**되고, 그 후 마이크로태스크가 모두 실행되어야만 다음 phase로 넘어갑니다.

---


